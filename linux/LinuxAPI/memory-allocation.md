# Выделение памяти

## Выделение памяти в куче

Процесс может выделить память, увеличив размер **кучи** (сегмента непрерывной виртуальной памяти переменного размера).

### Установка крайней точки программы (syscalls)
- int brk(void *end_data_segment); - устанавливает крайнюю точку программы на место, указанное окончанием сегмента данных — end_data_segment.
- void *sbrk(intptr_t increment); - приводит к изменению положения точки программы путем добавления к ней приращения increment. Возвращает предыдущий адрес крайней точки программы.

После того как эта точка будет сдвинута вверх, программа сможет получать доступ к любому адресу во вновь выделенной области, 
но страницы физической памяти пока выделяться не будут.

### Выделение памяти в куче: malloc() и free()

семейство функций malloc:
- часть С (стандарт)
- проще в использовании в программах, выполняемых в нескольких потоках;
- предоставляют простой интерфейс, позволяющий выделять память небольшими блоками;
- позволяют произвольно высвобождать блоки памяти, сохраняемые в списке свободных блоков и заново возвращаемые в оборот при последующих вызовах выделения памяти.

- void *malloc(size_t size); - Возвращает при успешном завершении указатель на выделенную память или NULL при ошибке

Если память не может быть выделена (например, по причине достижения того предела, до которого может быть поднята крайняя точка программы), 
функция malloc() возвращает NULL и устанавливает для errno значение, указывающее на характер ошибки.

free() не сдвигает вниз крайнюю точку программы, а добавляет блок памяти к списку свободных блоков для переиспользования malloc().
- Высвобождаемый блок памяти обычно находится где-нибудь в середине кучи, поэтому сдвинуть вниз крайнюю точку программы не представляется возможным
- Свести к минимумы вызовы sbrk()
- Бессмысленно сдвигать крайнюю точку вниз, поскольку подобные программы имеют склонность повторно выделять память, а не высвободить ее целиком надолго

Если же будет высвобожден весь набор блоков в верхней части кучи, free() вызовев sbrk(), чтобы снизить положение крайней точки программы.
Только когда высвобождаемый блок на вершине кучи «достаточно» большой. Здесь «достаточность» определяется параметрами, 
которые управляют операциями пакета функции из семейства malloc (обычно это 128 Кбайт). Тем самым снижается количество необходимых вызовов sbrk().

Причины, по которым желательно явное высвобождение всей выделенной памяти:
- читаемость и упрощение сопровождение программы при необходимости ее доработок
- может усложнить задачу выявлеения реальных утечек памяти при отладке

Реализация malloc():
- сканирует список ранее высвобожденных функцией free() блоков памяти, чтобы найти тот блок нужного размера (разные стратегии)
- если блок == по размеру, то он возвращается
- если блок > по размеру, то он разбивается, а выделенный свободный блок остается в списке
- если не найдется блока, то вызовется sbrk() и выделяет память с избытком (> чем требуется)

Никогда не следует вызывать функцию free() со значением указателя, которое небыло получено путем вызова одной из функций из пакета malloc.

### Выделение памяти с помощью функций calloc() и realloc()

- void *calloc(size_t numitems, size_t size); - выделяет память для массива одинаковых элементов. Возвращает указатель на выделенную память
- void *realloc(void *ptr, size_t size); - изменения размера (обычно увеличения) блока памяти, ранее выделенного одной из функций из пакета malloc.

В случае успеха функция realloc() возвращает указатель на местонахождение блока, размер которого был изменен.
Оно может отличаться от его местонахождения до вызова этой функции, поскольку если она находится в середине куче, то требуется ее скопировать в конец и выделить новый блок.
Это требовательно к ресурсам ЦПУ.

## Выделение выровненной памяти: memalign() и posix_memalign()

Предназначены для выделения памяти, начиная с адреса, который будет кратен некоторой степени двойки.

- void *memalign(size_t boundary, size_t size);
- int posix_memalign(void **memptr, size_t alignment, size_t size);

posix_memalign:
- адрес выделенной памяти возвращается в memptr;
- память выравнивается по значению степени числа два, которое кратно значению sizeof(void *)

## Выделение памяти в стеке: alloca()

Вмести кучи alloca() получает память из стека путем увеличения размера стекового фрейма.

- void *alloca(size_t size);

Если в результате вызова alloca() произойдет переполнение стека, поведение программы станет непредсказуемым.

Преимущества alloca():
- блоки памяти выделяются быстрее, ечем с malloc()
- не требуется списка свобных блоков
- память автоматически высвобождается при удалении стекового фрейма, т.е. когда происходит выход из функции вызвавшей alloca()

## Source
- https://codebrowser.dev/glibc/glibc/malloc/malloc.c.html
