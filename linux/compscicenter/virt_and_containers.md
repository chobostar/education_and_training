# Контейнерная виртуализация в Linux

docker - набор утилит и библиотек, который позволяет создавать и управлять контейнерами.

Какое окружение у процесса есть в контейнере?

### Namespace vs CGroups
- Namespace - механизм изоляции и группировки структур данных ядра
  - можно создать изолированное namespace, в которых будут только процессы определенной группы и нумероваться с 1
- Control groups - механизм изоляции ресурсов ядра
  - разные ресурсы ограничить или определить, который может использовать тот или иной процесс

https://github.com/torvalds/linux/blob/v5.9/include/linux/sched.h#L631
https://github.com/torvalds/linux/blob/v5.9/include/linux/nsproxy.h#L31-L41

- у процесса групповой tgid == pid (совпадает) 
- у потока tgid == pid процессу

шедулер не разбирается - поток или процесс, но есть возможность смотреть какому namespace оно относится.

### Namespaces API
- clone()
Самый первый процесс при запуске linux - init. Все остальные процессы появляются клонированием от init.
Клонирование - task_struct копируется, берется следующий идентификатор, берется родитель - инициализиуется это поле в новом процессе итд.
Корень файловой система.

- unshare()
Уже созданный процесс меняет namespace. 

- setns()
Явно указать namespace

### Namespaces
- Mount
пространство имен которое описывает иерархию файловой системы

mount namespace - копия дерева файловой системы, ассоциированная с процессом
создание: clone (..., ..., CLONE_NEWNS, ...)
опции: 
  - распространение событий монтирования (должен ли видить новые маунты потомок, или так же следить за потомком)
  - запрет перемонтирования (песочница)

#### Флаги mount
- bind - смотнирровать существующее дерево в другую точку (поддерево будет доступно в обоих местах)

Распространение изменений:
- make-shared
- make-slave (наследует изменения родителей)
- make-private (родителю ничего не распространяется)
- make-unbindable (запрет на перемонтирование)

Подробнее: https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt

- UTS
имя своего компьютера, хоста

#### UTS namespace
- изоляция имени хоста и доменного имени
- utsname:
    - sysname
    - nodename
    - release
    - ...

kernel space / user space.
из user space для обращение к ядру требуется вызывать системные вызовы.
чтобы код из user space мог единообразно опрашивать ядра есть иерархия файлов - `/proc/` (procfs)

#### Удержание namespace
namespace существует пока существует процесс. Чтобы не терять файл, создаем каталог (точка в ФС) и делаем mount --bind procfs внутрь каталога. Потом можно делать setns.
```
$ touch ./uts
$ mount --bind /proc/6221/ns/uts ./uts
```

- PID
номера процессов

#### PID namespace

ns могут быть вложенными

- назначение: изолияция идентификаторов процессов
- создание: clone (...)
- возможности:
    - миграция контейнеров с сохранением PIDS
    - имитация init-процесса
    - могут быть вложенными

- IPC
очереди io, нумерация ресурсов 

изоляция ресурсов IPC (System V IPC) - очередь сообщений, разделяемая память

- user
внутри процесса можно быть root-ом (эф фективный userid 0)

#### USER namespace
- изоляция идентификаторов пользователей и групп
- возможности:
    - предоставление привелигированных операций непривилегированному пользователю внутри пространства имен
    - отображение пользователей и групп
- /proc/sys/kernel/overflowuid

capabilities - какими возможностями/правами обладает конкретный процесс


#### Network namespace
наборы имен сетевых интерфейсов

- изоляция сетевой конфигурации, интерфейсов, правил маршрутизации

Примеры (через ip):
- ip netns add netns1
- ip netns exec netns1 ip link list
- ip netns delete netns1
- ip netns exec netns1 ip link set dev lo up
- ip netns exec netns1 ping 127.0.0.1


## Control groups
Возможность группировать ресурсы и контролировать их
#### Подсистемы Linux
История: как построить иерархию, чтобы описать управление питанием, чтобы узнать в каком порядке выключать?

sysfs - как procfs позволяет смотреть на ядро. Объект это каталог в sysfs, файл это аттрибут этогго каталога, могут быть подкаталоги. Можно записать/читать.

- Подсистема (subsystem) - модуль предоставляющий возможности для группировки и управления (ограничение, подсчет использования, ...) определенными ресурсами процессов.
- Контрольная группа (Control Cgroup, cgroup) - множество параметров, ассоциированное с одной или более подсистема.

"Эти процессы хотим, чтобы выполнялись на 1-2 процессорах. А остальные на 3-4."

#### Иерархия ресурсов и контрольные группы
Есть процессы внутри OS:
- использует одни устройства
- использует память
- использует CPU

и может это делать из разных групп. Одну и то жу же иерархию нельзя применить на разные группы.

иерархия:
- Устройства
- CPUs 0-15
    - продуктовые сервис 0-8
    - пользователи 9-12
    - службы 13-15
- Память (100% всего есть)<br>
    - процессы пользователей (30% едят)<br>
        - работники
           - QA (5%)
           - разработчики (15%)
    - системные (10%)
    - службы (50%) 
    - итд        

#### Обзор  контроллеров
компонент (подсистема) который позволяет устанавливать и контроливать

- blkio - управление вводом выводом блочный устройств
- cpu - управление доступом к процессору
- cpuacc - отчеты по использованию процессора
- cpuset - приязка к процессорам и банкам памяти
- devices - доступ к устройствам
- freezer - останов/возобнолвение работы группы
- memory - ограничения и учет использования памяти
- net_cls - маркировка пакетов для контроллера трафик (net классифайер)

#### Файлы cgroup
- /proc/cgroups (какие поддерживаются ядром)
- /proc/self/cgroup - группы процесса
- /sys/fs/cgroup (/cgroup) - корень иерархии  
- */tasks - PIDs участников группы
- */cgroup.procs - список thread groups
- */notify_on_release - флаг вызова агента разрешения (по-умолчанию 0)
- */release_agent - путь к агенту разрушения

#### Примеры
Создание группы

- cgcreate
    - t uid:gid - пользователи получающие права на перемещение заданий в(из) группы
    - a uid:gid - пользователи получающие права на управление параметрами группы
    - g список подсистем (контроллеров):путь
- Пример
```
$ cgcreate -t kkv:kkv -g memory,cpu:/mycgroup
```
добавить PID в cgroup:
```
$ echo 123 > */tasks
```

Удаление группы

- cgdelete
    - g список подсистем (контроллеров):путь
    - пример:
    ```
        cgdelete -g memory,cpu:/mycgroup
    ```
    (*) при удалении группы, входящие в нее задачи перемещаются в родительскую группу

Перемещение процессов в группу
- cgclassify
    - g список подсистем (контроллеров):путь PID [PID PID ...]
- примеры:
```
$ cgclassify -g cpu:/mycgroup 6433 3662
$ echo 6433 > /sys/fs/cgroup/cpi
```    

Выполнение процесса в группе

- cgexec
    - g список подсистем (контроллеров):путь имя_приложения
- Пример
```
$ cgexec -g memory:/mycgroup google-chrome
```
(у работающего процесса нельзя уменьшить выделенную память, приложение само должно уметь)

#### Настройка параметров контроллера

- cgget
  - r параметр группа
  - Пример:
  ```
    $ cgget -r cpu.shared /mycgroup
    >/mycgroup
    >cpu.shared: 1024
  
    cat /sys/fs/cgroup/cpu/mycgroup/cpu.shared
    >1024  
  ```
- cgset
    - Пример:
    ```
    $ cgset -r cpu.shares=8 /mycgroup
    $ echo 9 > /sys/fs/cgroup/cpu/mycgroup/cpu.shares
    ```
#### Контроллер cpuset
- Назначение: управление привязкой процессоров и памяти к процессам
- cpuset. cpus - список привязанных процессоров
- cpuset. mems - список привязанных банков памяти
- cpuset. cpu_exclusive - флаг эксклюзивного использования процессора группой
- cpuset.sched_laod_balance + cpuset.sched_relax_domain_level - управление балансировокой нагрузки в группе 

### Контроллер cpu
- Назначение: управление распределением нагрузки на процессоры
- cpu.shared - для использования процессора по отношению к друугим группам
- cpu.rt_runtime_us - максимальный период монопольного использования процессора в микросекундах
- cpu.rt_period_us - максимальное время ожидания процессора группой

### Контроллер cpuaccts
https://youtu.be/rJRLZfk3a8U?list=WL&t=5115