# Контейнерная виртуализация в Linux

docker - набор утилит и библиотек, который позволяет создавать и управлять контейнерами.

Какое окружение у процесса есть в контейнере?

### Namespace vs CGroups
- Namespace - механизм изоляции и группировки структур данных ядра
  - можно создать изолированное namespace, в которых будут только процессы определенной группы и нумероваться с 1
- Control groups - механизм изоляции ресурсов ядра
  - разные ресурсы ограничить или определить, который может использовать тот или иной процесс

https://github.com/torvalds/linux/blob/v5.9/include/linux/sched.h#L631
https://github.com/torvalds/linux/blob/v5.9/include/linux/nsproxy.h#L31-L41

- у процесса групповой tgid == pid (совпадает) 
- у потока tgid == pid процессу

шедулер не разбирается - поток или процесс, но есть возможность смотреть какому namespace оно относится.

### Namespaces API
- clone()
Самый первый процесс при запуске linux - init. Все остальные процессы появляются клонированием от init.
Клонирование - task_struct копируется, берется следующий идентификатор, берется родитель - инициализиуется это поле в новом процессе итд.
Корень файловой система.

- unshare()
Уже созданный процесс меняет namespace. 

- setns()
Явно указать namespace

### Namespaces
- Mount
пространство имен которое описывает иерархию файловой системы

mount namespace - копия дерева файловой системы, ассоциированная с процессом
создание: clone (..., ..., CLONE_NEWNS, ...)
опции: 
  - распространение событий монтирования (должен ли видить новые маунты потомок, или так же следить за потомком)
  - запрет перемонтирования (песочница)

#### Флаги mount
- bind - смотнирровать существующее дерево в другую точку (поддерево будет доступно в обоих местах)

Распространение изменений:
- make-shared
- make-slave (наследует изменения родителей)
- make-private (родителю ничего не распространяется)
- make-unbindable (запрет на перемонтирование)

Подробнее: https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt

- UTS
имя своего компьютера, хоста

#### UTS namespace
- изоляция имени хоста и доменного имени
- utsname:
    - sysname
    - nodename
    - release
    - ...

kernel space / user space.
из user space для обращение к ядру требуется вызывать системные вызовы.
чтобы код из user space мог единообразно опрашивать ядра есть иерархия файлов - `/proc/` (procfs)

#### Удержание namespace
namespace существует пока существует процесс. Чтобы не терять файл, создаем каталог (точка в ФС) и делаем mount --bind procfs внутрь каталога. Потом можно делать setns.
```
$ touch ./uts
$ mount --bind /proc/6221/ns/uts ./uts
```

- PID
номера процессов

#### PID namespace

ns могут быть вложенными

- назначение: изолияция идентификаторов процессов
- создание: clone (...)
- возможности:
    - миграция контейнеров с сохранением PIDS
    - имитация init-процесса
    - могут быть вложенными

- IPC
очереди io, нумерация ресурсов 

изоляция ресурсов IPC (System V IPC) - очередь сообщений, разделяемая память

- user
внутри процесса можно быть root-ом (эф фективный userid 0)

#### USER namespace
- изоляция идентификаторов пользователей и групп
- возможности:
    - предоставление привелигированных операций непривилегированному пользователю внутри пространства имен
    - отображение пользователей и групп
- /proc/sys/kernel/overflowuid

capabilities - какими возможностями/правами обладает конкретный процесс


#### Network namespace
наборы имен сетевых интерфейсов

- изоляция сетевой конфигурации, интерфейсов, правил маршрутизации

Примеры (через ip):
- ip netns add netns1
- ip netns exec netns1 ip link list
- ip netns delete netns1
- ip netns exec netns1 ip link set dev lo up
- ip netns exec netns1 ping 127.0.0.1


#### Control groups
https://youtu.be/rJRLZfk3a8U?list=WL&t=2937