Kubernetes в действии. Марко Лукша
==================================

## Глава 1. Знакомство с K8S

Монолиты имеют медленные циклы релизов и редко обновляются. Монолиты дробятся на микросервисы, чтобы разрабатываться независимо и быстро. 
Нужна автоматика по деплойменту, настройке, контролю и обработке аварийных сбоев. Именно здесь в игру вступает Kubernetes.

Kubernetes:
- разработчики деплоят свои приложения самостоятельно и так часто
- разработчикам для деплоя не требуется помощь системных администраторов
- помогает автоматически отслеживать и перемещать приложения в случае сбоев оборудования
- сисадмины - контроль за платформой k8s и остальной инфраструктурой
- k8s сама заботится о приложениях

DevOps - разработка, QA и сисадмины  сотрудничают на протяжении всего процесса
NoOps - разработчики деплоят, не зная об аппаратной инфраструктуре и не имея дела с сисадминами

K8s позволяет достичь NoOps.

Приложения изолируют свои среды через контейнеры. Виртуалки требуется индивидуальной настройки и управления, 
требуют траты человеческих ресурсов.

Каждая VM требует запускать свой набор системных процессов, который требует еще вычислительных ресурсов в дополнение, 
что требуется приложением. Контейнер выполняется в центральной ОС, без накладных расходов в виде доп ресурсов.

namespaces - каждый процесс видит свое персональное представление о системе (файлы, процессы, сетевые интерфейсы, hostname итд)
cgroups - ограничивает объем ресурсов, которые может потреблять процесс (cpu, ram, network throthput etc)

Компоненты K8s:
- control plane (master):
    - etcd - непрерывно сохраняетт конфигурацию кластера
    - сервер API - то с чем взаимодействует другие компоненты и человек
    - менеджер контроллеров - выполняет функции кластерного уровня, как репликация компонентов, отслеж нод, обработка отказов итд
    - планировщик - распределяет приложения по нодам
- Рабочий узел (kube node):
    - kubelet - агент, общаяется с сервером API и управляет контейнерами на своем узле
    - docker runtime
    - kube-proxy - балалнсирует нагрузку сетевого трафика между компонентами приложения

#### Запуск приложений в k8s

Сборка приложения в один или несколько контейнеров, отправка их в хранилище образов, а затем публикация описания приложения на сервере API K8s

Когда сервер API обрабатывает описание приложения, планировщик назначает указанные группы контейнеров доступным рабочим узлам, исходя из
вычислительных ресурсов, требуемых каждой группой, и нераспределенных ресурсов на каждом узле в данных момент.
Агент Kubelet на этих узлах затем поручает среде выполнения контейнеров (docker runtime) извлечь из хранилища требуемые
образы контейнеров и запустить контейнеры.

После запуска приложения k8s следит за тем, чтобы то состояние, в котором было развернуто приложение, всегда соответствовало указанному вами описанию.

Можно сообщить k8s, какие контейнеры предосталяют одну и ту же службу, и k8s обеспечит доступ ко всем контейрнерам по единому статическому IP и предоставит
доступ к этому адресу всем приложениям, работающим в кластере. Это делается через env vars, но можно и через DNS. kube-proxy обеспечивает балансировку нагрузки
подключений к службе во всех контейнерах, предоставляющих службу. IP-адрес службы остается постоянным, поэтому клиенты всегда могут подключаться к ее контейнерам, даже
если они перемещаются по кластеру.

#### Преимущества использования k8s
- Упрощение развертывания приложения
- Повышение эффективности задействования оборудования
- Проверка здоровья и самолечение
- Автоматическое масштабироваие
- Упрощение разработки приложений



