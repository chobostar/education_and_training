Kubernetes в действии. Марко Лукша
==================================

- [Kubernetes в действии. Марко Лукша](#kubernetes-----------------------)
  * [Глава 1. Знакомство с K8S](#------1--------------k8s)
    - [Запуск приложений в k8s](#--------------------k8s)
    - [Преимущества использования k8s](#---------------------------k8s)

## Глава 1. Знакомство с K8S

Монолиты имеют медленные циклы релизов и редко обновляются. Монолиты дробятся на микросервисы, чтобы разрабатываться независимо и быстро. 
Нужна автоматика по деплойменту, настройке, контролю и обработке аварийных сбоев. Именно здесь в игру вступает Kubernetes.

Kubernetes:
- разработчики деплоят свои приложения самостоятельно и так часто
- разработчикам для деплоя не требуется помощь системных администраторов
- помогает автоматически отслеживать и перемещать приложения в случае сбоев оборудования
- сисадмины - контроль за платформой k8s и остальной инфраструктурой
- k8s сама заботится о приложениях

DevOps - разработка, QA и сисадмины  сотрудничают на протяжении всего процесса
NoOps - разработчики деплоят, не зная об аппаратной инфраструктуре и не имея дела с сисадминами

K8s позволяет достичь NoOps.

Приложения изолируют свои среды через контейнеры. Виртуалки требуется индивидуальной настройки и управления, 
требуют траты человеческих ресурсов.

Каждая VM требует запускать свой набор системных процессов, который требует еще вычислительных ресурсов в дополнение, 
что требуется приложением. Контейнер выполняется в центральной ОС, без накладных расходов в виде доп ресурсов.

namespaces - каждый процесс видит свое персональное представление о системе (файлы, процессы, сетевые интерфейсы, hostname итд)
cgroups - ограничивает объем ресурсов, которые может потреблять процесс (cpu, ram, network throthput etc)

Компоненты K8s:
- control plane (master):
    - etcd - непрерывно сохраняетт конфигурацию кластера
    - сервер API - то с чем взаимодействует другие компоненты и человек
    - менеджер контроллеров - выполняет функции кластерного уровня, как репликация компонентов, отслеж нод, обработка отказов итд
    - планировщик - распределяет приложения по нодам
- Рабочий узел (kube node):
    - kubelet - агент, общаяется с сервером API и управляет контейнерами на своем узле
    - docker runtime
    - kube-proxy - балалнсирует нагрузку сетевого трафика между компонентами приложения

#### Запуск приложений в k8s

Сборка приложения в один или несколько контейнеров, отправка их в хранилище образов, а затем публикация описания приложения на сервере API K8s

Когда сервер API обрабатывает описание приложения, планировщик назначает указанные группы контейнеров доступным рабочим узлам, исходя из
вычислительных ресурсов, требуемых каждой группой, и нераспределенных ресурсов на каждом узле в данных момент.
Агент Kubelet на этих узлах затем поручает среде выполнения контейнеров (docker runtime) извлечь из хранилища требуемые
образы контейнеров и запустить контейнеры.

После запуска приложения k8s следит за тем, чтобы то состояние, в котором было развернуто приложение, всегда соответствовало указанному вами описанию.

Можно сообщить k8s, какие контейнеры предосталяют одну и ту же службу, и k8s обеспечит доступ ко всем контейрнерам по единому статическому IP и предоставит
доступ к этому адресу всем приложениям, работающим в кластере. Это делается через env vars, но можно и через DNS. kube-proxy обеспечивает балансировку нагрузки
подключений к службе во всех контейнерах, предоставляющих службу. IP-адрес службы остается постоянным, поэтому клиенты всегда могут подключаться к ее контейнерам, даже
если они перемещаются по кластеру.

#### Преимущества использования k8s
- Упрощение развертывания приложения
- Повышение эффективности задействования оборудования
- Проверка здоровья и самолечение
- Автоматическое масштабироваие
- Упрощение разработки приложений

## Глава 2. Первые шаги с Docker и Kubernetes

#### docker commands
```
$ docker build -t kubia .
$ docker run --name kubia-container -p 8080:8080 -d kubia
$ curl localhost:8080
$ docker ps
$ docker inspect kubia-container
$ docker exec -it kubia-container bash
$ docker stop kubia-container
$ docker rm kubia-container
$ docker tag kubia somename/kubia
$ docker push somename/kubia
```

#### k8s commands
```
$ minikube start
$ kubectl cluster-info
$ kubectl get nodes
$ kubectl describe node minikube
$ kubectl run kubia --image=somename/kubia --port=8080 --generator=run/v1
$ kubectl get pods
$ kubectl expose rc kubia --type=LoadBalancer --name kubia-http
$ minikube serivce kubia-http
$ kubectl get services
$ kubectl get svc
$ kubectl get replicationcontrollers
$ kubectl scale rc kubia --replicas=3
$ kubectl get rc
$ kubectl get pods
$ kubectl get pods -o wide
$ kubectl describe pod <podname>
$ minikube dashboard
```
