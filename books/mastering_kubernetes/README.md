Kubernetes в действии. Марко Лукша
==================================

- [Kubernetes в действии. Марко Лукша](#kubernetes-----------------------)
  * [Глава 1. Знакомство с K8S](#------1--------------k8s)
    - [Запуск приложений в k8s](#--------------------k8s)
    - [Преимущества использования k8s](#---------------------------k8s)

## Глава 1. Знакомство с K8S

Монолиты имеют медленные циклы релизов и редко обновляются. Монолиты дробятся на микросервисы, чтобы разрабатываться независимо и быстро. 
Нужна автоматика по деплойменту, настройке, контролю и обработке аварийных сбоев. Именно здесь в игру вступает Kubernetes.

Kubernetes:
- разработчики деплоят свои приложения самостоятельно и так часто
- разработчикам для деплоя не требуется помощь системных администраторов
- помогает автоматически отслеживать и перемещать приложения в случае сбоев оборудования
- сисадмины - контроль за платформой k8s и остальной инфраструктурой
- k8s сама заботится о приложениях

DevOps - разработка, QA и сисадмины  сотрудничают на протяжении всего процесса
NoOps - разработчики деплоят, не зная об аппаратной инфраструктуре и не имея дела с сисадминами

K8s позволяет достичь NoOps.

Приложения изолируют свои среды через контейнеры. Виртуалки требуется индивидуальной настройки и управления, 
требуют траты человеческих ресурсов.

Каждая VM требует запускать свой набор системных процессов, который требует еще вычислительных ресурсов в дополнение, 
что требуется приложением. Контейнер выполняется в центральной ОС, без накладных расходов в виде доп ресурсов.

namespaces - каждый процесс видит свое персональное представление о системе (файлы, процессы, сетевые интерфейсы, hostname итд)
cgroups - ограничивает объем ресурсов, которые может потреблять процесс (cpu, ram, network throthput etc)

Компоненты K8s:
- control plane (master):
    - etcd - непрерывно сохраняетт конфигурацию кластера
    - сервер API - то с чем взаимодействует другие компоненты и человек
    - менеджер контроллеров - выполняет функции кластерного уровня, как репликация компонентов, отслеж нод, обработка отказов итд
    - планировщик - распределяет приложения по нодам
- Рабочий узел (kube node):
    - kubelet - агент, общаяется с сервером API и управляет контейнерами на своем узле
    - docker runtime
    - kube-proxy - балалнсирует нагрузку сетевого трафика между компонентами приложения

#### Запуск приложений в k8s

Сборка приложения в один или несколько контейнеров, отправка их в хранилище образов, а затем публикация описания приложения на сервере API K8s

Когда сервер API обрабатывает описание приложения, планировщик назначает указанные группы контейнеров доступным рабочим узлам, исходя из
вычислительных ресурсов, требуемых каждой группой, и нераспределенных ресурсов на каждом узле в данных момент.
Агент Kubelet на этих узлах затем поручает среде выполнения контейнеров (docker runtime) извлечь из хранилища требуемые
образы контейнеров и запустить контейнеры.

После запуска приложения k8s следит за тем, чтобы то состояние, в котором было развернуто приложение, всегда соответствовало указанному вами описанию.

Можно сообщить k8s, какие контейнеры предосталяют одну и ту же службу, и k8s обеспечит доступ ко всем контейрнерам по единому статическому IP и предоставит
доступ к этому адресу всем приложениям, работающим в кластере. Это делается через env vars, но можно и через DNS. kube-proxy обеспечивает балансировку нагрузки
подключений к службе во всех контейнерах, предоставляющих службу. IP-адрес службы остается постоянным, поэтому клиенты всегда могут подключаться к ее контейнерам, даже
если они перемещаются по кластеру.

#### Преимущества использования k8s
- Упрощение развертывания приложения
- Повышение эффективности задействования оборудования
- Проверка здоровья и самолечение
- Автоматическое масштабироваие
- Упрощение разработки приложений

## Глава 2. Первые шаги с Docker и Kubernetes

#### docker commands
```
$ docker build -t kubia .
$ docker run --name kubia-container -p 8080:8080 -d kubia
$ curl localhost:8080
$ docker ps
$ docker inspect kubia-container
$ docker exec -it kubia-container bash
$ docker stop kubia-container
$ docker rm kubia-container
$ docker tag kubia somename/kubia
$ docker push somename/kubia
```

#### k8s commands
```
$ minikube start
$ kubectl cluster-info
$ kubectl get nodes
$ kubectl describe node minikube
$ kubectl run kubia --image=somename/kubia --port=8080 --generator=run/v1
$ kubectl get pods
$ kubectl expose rc kubia --type=LoadBalancer --name kubia-http
$ minikube serivce kubia-http
$ kubectl get services
$ kubectl get svc
$ kubectl get replicationcontrollers
$ kubectl scale rc kubia --replicas=3
$ kubectl get rc
$ kubectl get pods
$ kubectl get pods -o wide
$ kubectl describe pod <podname>
$ minikube dashboard
```

## Глава 3. Модули: запуск контейнеров в Kubernetes

Модули - размещенная рядом группа контейнеров, основной строительный блок в k8s:
- частичная изоляция между контейнерами одного модуля - один linux namespace: Network, UTS 
- использует одно пространство ip-адресов и портов
- один loopback-интерфейс
- все модули видят друг друга по ip - плоская сеть под модулями

модули являются логическими хостами и ведут себя как физические хосты или виртуальные машиы в неконтейнерном мире. Процессы
запущенные в одном модуле, подобны процессам, запущенным на одной физической или виртуальной машине, за исключением того, что
каждый процесс инкапсулируется в контейнер.

(здесь масштабирование - подразумевается горизонатальное масштабирование)

как контейнеры должны быть сгруппированы в модули:
- они должны работать вместе или могут работать на разных хостах?
- представляют ли они собой единое целое или являются независимымми компонентами?
- они должны масштабироваться вместе или по отдельности?

Контейнер не должен выполнять несколько процессов. 
Модуль не должен содержать многочисленные контейнеры, если они не обязатятельно должны выполняться на одинаковой машине.

### Создание модулей из дескрипторов YAML и JSON

Модули и другие ресурсы K8s обычно создаются путеем публикации манифеста json или yaml в конечной точке k8s rest api. Более простые - kubectl run.

```
kubectl get po kubia-zxzij -o yaml
```

Почти во всех ресурсах k89s находятся три каждые секции:
- metadata - вклчюает имя, пространство имен, метки и другую информацию о модуле;
- spec - содержит фактическое описание содержимого модуля, напрмер контейнеры модуля, тома и другие данные;
- status - содержит текущую информацию о работающем модуле, как условие, в котором находится модуль описание и статус каждого контейнера, внутренний IP модуля, и другую базовую информацию.

```
kubectl explain pods
```
```
kubectl create -f kubia-manual.yaml
```

#### Label selectors

- содержит ли (или не содержит) ресурс метку с определенным ключом;
- содержит ли ресурс метку с определенным ключом и значением;
- содержил ли ресурс метку с определенным ключом, но со значением, не равным указанному вами;

```
kubectl get po - l creation_methoh=manual
kubectl get po -l env
kubectl get go -l '!env'
```

#### Резюме
- метки и селекторы меток следует использовать для организации моудлей и упрощения выполнения операций с несколькими модулями одновременно;
- метки и селекторы узлов можно использовать, чтобы назначать модули только тем узлам, котроые имеют определенные функциональные особенности;
- аннотации позволяют приклеклять более крупные блобы данных к модулям, и это делается либо пользователями, либо инструментами и библиотеками;
- пространства имен можно использовать для того, чтобы разные группы специалистов могли использовать тот же кластер, как если бы они использовали разные кластеры K8s;
