Чистая архитектура. Роберт Мартин
=================================
- [Чистая архитектура. Роберт Мартин](#--------------------------------)
      - [История о двух ценностях](#------------------------)
  * [Парадигмы программирования](#--------------------------)
    + [Структурное программирование](#----------------------------)
    + [Объектно-ориентированное программирование](#-----------------------------------------)
    + [Функциональное программирование](#-------------------------------)
  * [Принципы дизайна](#----------------)
    + [Принцип единственной ответственности](#------------------------------------)
    + [Принцип открытости/закрытости](#-----------------------------)
    + [Принцип подстановки Барбары Лисков](#----------------------------------)
    + [Принцип разделения интерфейсов](#------------------------------)
    + [Принцип инверсии зависимостей](#-----------------------------)
  * [Принципы организации компонентов](#--------------------------------)
  * [Связность компонентов](#---------------------)
    + [Диаграмма противоречий для определения связности компонентов](#------------------------------------------------------------)
 
Как выглядит добротная, чистая архитектура и дизайн, чтобы разработчики могли создавать системы, способные приносить
прибыль долгое время.

Цель. Уменьшить трудозатраны на создание и сопровождение.

#### История о двух ценностях

поведение - срочное
архитектура - важное

Приоритеты:
1. Срочные и важные
2. Не срочные и важные
3. Срочные и неважные
4. Не срочные и неважные

Руководители неспособны оценить важность архитектуры. _Именно для ее решение наняты разработчики_. 

## Парадигмы программирования

_Структурное программирование_ накладывает ограничение на прямую переносимость управления

_Объектно-ориентированное программирование_ накладывает ограничение на косвенную передачу управления

_Функциональное программирование_ накладывает ограничение на присваивание

Мы используем полиморфизм как механизм преодоления архитектурных границ, мы используем функциональное программирование
для наложения ограничений на местоположение данных и порядок доступа к ним, и мы используем структурное
программирование, как алгоритмическую основу для наших модулей.

3 главнейшние аспекты строительства архитектуры: функциональности, разделению компонентов и управлению данными.

### Структурное программирование

Дейсктра "Тестирование показывает присутствие ошибок, а не их отсутствие". Тестирование можно доказать неправильность
программы, но нельзя доказать ее правильность. Только уверенность, что программа действует достаточно правильно.

Стремиться определить модули, компоненты и службы, неправильность которых легко можно было бы доказать (протестировав).
Для этого используются ограничения, напоминающие ограничения в структурном программировании.

### Объектно-ориентированное программирование

Полиморфизм для инверсии зависимостей. Любую зависимость исходного кода, где бы она ни находилась, можно инвертировать.

Независимость развертывания -> независимость разработки

ООП дает, посредством поддержки полиморфизма, абсолютный контроль над всеми зависимостями в исходном коде. Это позволяет
создать архитектуры со сменными модулями (плагинами), в которой модули верхнего уровня не зависят от модулей нижнего
уровня. Низкоуровненые детали не выходят за рамки модулей плагинов, которые можно развертывать и разрабатывать незамесимо
от модулей верхнего уровня.

### Функциональное программирование

race condition, dead locks и проблемы параллельного обновления обусловлены изменяемостью переменных.

Приложения должны делиться на компоненты, имеющие и не имеющие изменяемых переменных. (отделять immutable от mutable)

## Принципы дизайна

Цель SOLID:
- терпимы к изменениям
- просты и понятны
- образуют основу для компонентов, которые могут использоваться во многих программных системах

### Принцип единственной ответственности

Модуль должен отвечать за одного и только за одного актора.

SRP на уровне компонентов превращается в принцип согласованного изменения - CCP (Common Clouse Principle), а на
архитектурном уровне - принцип оси изменения (Axis of Change), отвечающий за создание архитектурных границ.

### Принцип открытости/закрытости

Программные сущности должны быть открыты для расширения и закрыты для изменения.

Должна иметься возможность расширять поведение программных сущностей без их изменения.

Архитекторы разделяют функциональные возможности, опираясь на то, как, почему и когда их может по может потребоваться
изменить, и затем организуют их в иерархию компонентов. Компоненты, находящиеся на верхних уровнях в такой иерархии,
защищаются от изменений в компонентах на нижних уровней.

Если компонент A требуется защитить от изменений в компоненте B, компонент B должен зависеть от компонента A.

Цель - сделать систему легко расширяемой и обезопасить ее от влияния изменений. Достигается делением системы на компоненты
и упорядочением их в зависимостей в иерархию, защищающую компоненты уровнем выше от изменений в компонентах уровнем ниже.

### Принцип подстановки Барбары Лисков

Нарушение совместимости может вызвать загрязнение архитектуры системы значительным количеством дополнительных механизмов.

### Принцип разделения интерфейсов

Опасно создавать зависимости от модулей, содержащих больше, чем требуется. Может стать причиной неожиданных проблем.
Это справедливо не только в отношении зависимостей в коде, которые вынуждают выполнять без необходимости повторную компиляцию и развертывание, но также и на
уровне архитектуры.

### Принцип инверсии зависимостей

Наиболее гибкими получаются системы, в которых зависимости в исходном коде направлены на абстракции, а не на конкретные
реализации.

Стабильные называются такие архитектуры, в которых вместо зависимостей от переменчивых конкретных реализаций используются
зависимости от стабильных абстрактных интерфейсов. Набор правил:
- не ссылайтесь на изменчивые конкретные классы
- не наследуйте изменчивые конкретные классы
- не переопределяйте конкретные функции
- никогда не ссылайтесь на имена конкретных и изменчивых сущностей

## Принципы организации компонентов

Компоненты - это единицы развертывания. Они представляют наименьшие сущности, которые можно развертывать в составе системы.

## Связность компонентов

Принципы определяющих связность компонентов:
- REP: Reuse/Release Equivalence Principle - принцип эквивалентности повторного использования и выпусков
    - Единица повторного использования есть единица выпуска
- CCP: Common Closure Principle - принцип согласованного изменения
    - В один компонент должны включаться классы, изменяющиеся по одним причинам и в одно время. В разные компоненты
    включаться классы, изменяющиеся в разное время и по разным причинам.
    - Собирайте вмете все, что изменяется по одной причине и в одно время. Разделяйте все, что изменяется в разное время
    и по разным причинам.
- CRP: Common Reuse Principle - принцип совместного повторного использования
    - Не вынуждайте пользователей компонента зависеть от того, чего им не требуется.
    - Не создавайте зависимостей от чего-то неиспользуемого
 
 ### Диаграмма противоречий для определения связности компонентов
 
 Три принципа связности компонентов вступают в противоречие друг с другом.
 
 REP + CCP _включетельные_ принципы: оба стремяться сделать компоненты как можно крупнее
 
 CRP - _исключительный_ принцип: компоненты как можно мельче
 
 Диаграмма:
 - REP + CCP = слишком много ненужных выпусков
 - CCP + CRP = усложняется повторное использование
 - REP + CRP = изменения затрагивают слшиком большое количество компонентов
    















