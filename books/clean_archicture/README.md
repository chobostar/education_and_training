Чистая архитектура. Роберт Мартин
=================================

- [Чистая архитектура. Роберт Мартин](#--------------------------------)
      - [История о двух ценностях](#------------------------)
  * [Парадигмы программирования](#--------------------------)
    + [Структурное программирование](#----------------------------)
    + [Объектно-ориентированное программирование](#-----------------------------------------)
    + [Функциональное программирование](#-------------------------------)
  * [Принципы дизайна](#----------------)
    + [Принцип единственной ответственности](#------------------------------------)
    + [Принцип открытости/закрытости](#-----------------------------)
    + [Принцип подстановки Барбары Лисков](#----------------------------------)
    + [Принцип разделения интерфейсов](#------------------------------)
    + [Принцип инверсии зависимостей](#-----------------------------)
  * [Принципы организации компонентов](#--------------------------------)
  * [Связность компонентов](#---------------------)
    + [Диаграмма противоречий для определения связности компонентов](#------------------------------------------------------------)
  * [Сочетаемость компонентов](#------------------------)
    + [Принцип ацикличности зависимостей](#---------------------------------)
      - [Разрыв цикла](#------------)
    + [Принцип устойчивых зависимостей](#-------------------------------)
      - [Устойчивость](#------------)
      - [Метрики устойчивости](#--------------------)
      - [Абстрактные компоненты](#----------------------)
    + [Принцип устойчивости абстракций](#-------------------------------)
      - [Мера абстрактности](#------------------)
      - [Главная последовательность](#--------------------------)
  * [Архитектура](#-----------)
  * [Независимость](#-------------)
  * [Границы](#-------)
  * [Бизнес правила](#--------------)
 
Как выглядит добротная, чистая архитектура и дизайн, чтобы разработчики могли создавать системы, способные приносить
прибыль долгое время.

Цель. Уменьшить трудозатраны на создание и сопровождение.

#### История о двух ценностях

поведение - срочное
архитектура - важное

Приоритеты:
1. Срочные и важные
2. Не срочные и важные
3. Срочные и неважные
4. Не срочные и неважные

Руководители неспособны оценить важность архитектуры. _Именно для ее решение наняты разработчики_. 

## Парадигмы программирования

_Структурное программирование_ накладывает ограничение на прямую переносимость управления

_Объектно-ориентированное программирование_ накладывает ограничение на косвенную передачу управления

_Функциональное программирование_ накладывает ограничение на присваивание

Мы используем полиморфизм как механизм преодоления архитектурных границ, мы используем функциональное программирование
для наложения ограничений на местоположение данных и порядок доступа к ним, и мы используем структурное
программирование, как алгоритмическую основу для наших модулей.

3 главнейшние аспекты строительства архитектуры: функциональности, разделению компонентов и управлению данными.

### Структурное программирование

Дейсктра "Тестирование показывает присутствие ошибок, а не их отсутствие". Тестирование можно доказать неправильность
программы, но нельзя доказать ее правильность. Только уверенность, что программа действует достаточно правильно.

Стремиться определить модули, компоненты и службы, неправильность которых легко можно было бы доказать (протестировав).
Для этого используются ограничения, напоминающие ограничения в структурном программировании.

### Объектно-ориентированное программирование

Полиморфизм для инверсии зависимостей. Любую зависимость исходного кода, где бы она ни находилась, можно инвертировать.

Независимость развертывания -> независимость разработки

ООП дает, посредством поддержки полиморфизма, абсолютный контроль над всеми зависимостями в исходном коде. Это позволяет
создать архитектуры со сменными модулями (плагинами), в которой модули верхнего уровня не зависят от модулей нижнего
уровня. Низкоуровненые детали не выходят за рамки модулей плагинов, которые можно развертывать и разрабатывать незамесимо
от модулей верхнего уровня.

### Функциональное программирование

race condition, dead locks и проблемы параллельного обновления обусловлены изменяемостью переменных.

Приложения должны делиться на компоненты, имеющие и не имеющие изменяемых переменных. (отделять immutable от mutable)

## Принципы дизайна

Цель SOLID:
- терпимы к изменениям
- просты и понятны
- образуют основу для компонентов, которые могут использоваться во многих программных системах

### Принцип единственной ответственности

Модуль должен отвечать за одного и только за одного актора.

SRP на уровне компонентов превращается в принцип согласованного изменения - CCP (Common Clouse Principle), а на
архитектурном уровне - принцип оси изменения (Axis of Change), отвечающий за создание архитектурных границ.

### Принцип открытости/закрытости

Программные сущности должны быть открыты для расширения и закрыты для изменения.

Должна иметься возможность расширять поведение программных сущностей без их изменения.

Архитекторы разделяют функциональные возможности, опираясь на то, как, почему и когда их может по может потребоваться
изменить, и затем организуют их в иерархию компонентов. Компоненты, находящиеся на верхних уровнях в такой иерархии,
защищаются от изменений в компонентах на нижних уровней.

Если компонент A требуется защитить от изменений в компоненте B, компонент B должен зависеть от компонента A.

Цель - сделать систему легко расширяемой и обезопасить ее от влияния изменений. Достигается делением системы на компоненты
и упорядочением их в зависимостей в иерархию, защищающую компоненты уровнем выше от изменений в компонентах уровнем ниже.

### Принцип подстановки Барбары Лисков

Нарушение совместимости может вызвать загрязнение архитектуры системы значительным количеством дополнительных механизмов.

### Принцип разделения интерфейсов

Опасно создавать зависимости от модулей, содержащих больше, чем требуется. Может стать причиной неожиданных проблем.
Это справедливо не только в отношении зависимостей в коде, которые вынуждают выполнять без необходимости повторную компиляцию и развертывание, но также и на
уровне архитектуры.

### Принцип инверсии зависимостей

Наиболее гибкими получаются системы, в которых зависимости в исходном коде направлены на абстракции, а не на конкретные
реализации.

Стабильные называются такие архитектуры, в которых вместо зависимостей от переменчивых конкретных реализаций используются
зависимости от стабильных абстрактных интерфейсов. Набор правил:
- не ссылайтесь на изменчивые конкретные классы
- не наследуйте изменчивые конкретные классы
- не переопределяйте конкретные функции
- никогда не ссылайтесь на имена конкретных и изменчивых сущностей

## Принципы организации компонентов

Компоненты - это единицы развертывания. Они представляют наименьшие сущности, которые можно развертывать в составе системы.

## Связность компонентов

Принципы определяющих связность компонентов:
- REP: Reuse/Release Equivalence Principle - принцип эквивалентности повторного использования и выпусков
    - Единица повторного использования есть единица выпуска
- CCP: Common Closure Principle - принцип согласованного изменения
    - В один компонент должны включаться классы, изменяющиеся по одним причинам и в одно время. В разные компоненты
    включаться классы, изменяющиеся в разное время и по разным причинам.
    - Собирайте вмете все, что изменяется по одной причине и в одно время. Разделяйте все, что изменяется в разное время
    и по разным причинам.
- CRP: Common Reuse Principle - принцип совместного повторного использования
    - Не вынуждайте пользователей компонента зависеть от того, чего им не требуется.
    - Не создавайте зависимостей от чего-то неиспользуемого
 
 ### Диаграмма противоречий для определения связности компонентов
 
 Три принципа связности компонентов вступают в противоречие друг с другом.
 
 REP + CCP _включетельные_ принципы: оба стремяться сделать компоненты как можно крупнее
 
 CRP - _исключительный_ принцип: компоненты как можно мельче
 
 Диаграмма:
 - REP + CCP = слишком много ненужных выпусков
 - CCP + CRP = усложняется повторное использование
 - REP + CRP = изменения затрагивают слшиком большое количество компонентов


## Сочетаемость компонентов

### Принцип ацикличности зависимостей

Acyclic Dependencies Principle (ADP)

_Циклы в графе зависимостей компонентов недопустимы_

#### Разрыв цикла

1. DIP (Dependency Inversion Principle). Создать интерфейс внутри зависимого класса и унаследовать этот интерфейс внутри
необходимого. Таким образом обращаем зависимость.
2. Создать новый компонент, от которого теперь будут зависеть и зависимый и необходимый компонент.

Граф зависимостей компонентов создается и формируется архитекторами для защиты стабильных и ценных компонентов
от влияния изменчивых компонентов.

### Принцип устойчивых зависимостей

Stable Dependencies Principle (SDP)

_Зависимости должны быть направлены в сторону устойчивости_

#### Устойчивость

Связана с количеством работы, которое требуется проделать, чтобы изменить состояние.

#### Метрики устойчивости

- Fan-in: количество входящих зависимостей
- Fan-out: количество исходящих зависимостей
- I: неустойчивость: I = Fan-out / (Fan-i + Fan-out)
    - I=0 - максимальная устойчивость
    - I=1 - максимальная неустойчивость

#### Абстрактные компоненты

Очень устойчивы, поэтому служат идеальной целью для зависимостей в менее устойчивых компонентах

### Принцип устойчивости абстракций
 
Stable Abstractions Principle (SAP)

_Устойчивость компонента пропорциональная его абстрактности_

Зависимости должны быть направлены в сторону абстрактности

#### Мера абстрактности
- Nc - число классов в компоненте
- Na - число абстрактных классов и интерфейсов в компоненте
- A: абстрактностьи. A = Na / Nc
    - A=0 полное отсутствие абстрактных классов в компоненте
    - A=1 компонент не содержит ничего, кроме абстрактных классов

#### Главная последовательность

- D: расстояние. D = |A+I-1|
    - D=0 компонент находится прямо на главной последовательности
    - D=1 компонент максимально удален от главной последовательности
 
 Компонент на главной последовательности не слишком абстрактный для своей устойчивости и не слышком устойчив для своей
 абстрактности. Он не бесполезен и не доставляет особенной боли.
 
 - I=0, A=0 - зона боли
 - I=1, A=1 - зоне бесполезности
 
 ## Архитектура
 
 Главная стратегия упрощения в том, чтобы как можно дольше иметь как можно больше вариантов.
 
 Цель - минимизировать затраты на протяжении срока службы системы и максимизировать продуктивность программиста.
 
 Разработка. Развертывание. Эффективность работы. Сопровождение.
 
 Создать такую форму для системы, которая сделает политику самым важным элементов, а детали - не относящимися к политике.
 Это позволит откладывать и задерживать принятие решений о деталях.
 
 Хороший архитектор максимизирует количество непринятых решений.
  
 Например:
 - независимости от устройства вывода
 - неиспользовать физическую адресацию

## Независимость

Режимы разделения:
- Уровень исходного кода
- Уровень развертывания
- Уровень сервисов

Режим разделения системы на компоненты относится к числку вариантов, которые, скорее всего, будут изменяться со временем,
и хороший архитектор должен предывидеть такие изменения и стремиться к упрощению.

## Границы

Граница это "инкапсуляция". Отделяют программные элементы друг от друга и избавляют их от необходимости знать, что
находится по ту сторону.

Отделять линиями нужно все, что не имеет значения. Например, GUI vs бизнес-правила, GUI vs Database...

Прежде, чем провести линии границ в архитектуре ПО, систему нужно разделить на компоненты.
Некоторые из этих компонентов реализуют основные бизнес-правила; другия являются плагинами, содержащими функции, которые
не имеют прямой связи с бизнес-правилами. Затем можно огранизовать код в компонентах так, чтобы стрелки между ними
указывали в одном направлении - в сторону бизнес-правил.

Граница может быть:
- компоненты развертывания
- потоки выполненения
- локальные процессы
- сервисы

Уровень - "удаленность от ввода и вывода". Чем дальше, чем выше уровень.

_Низкоуровненые системы зависят от высокоуровневых_.

Тривиальные, но срочные изменения на более низких уровнях системы не влияют или слабо влияют на более высокие уровни.

## Бизнес правила

Бизнес-правила - это правила или процедуры, делающие или экономящие деньги. Например, банк взымает N% за кредит.

Вариант использования описывает способ использования автоматизированной системы. Определяют, как и когда вызываются
критические бизнес-правила в сущности, управляет действиями сущности.

Вариант использования низкоуровневый, потому что характерен для единственного приложения, т.е. ближе к вводу-выводу.

Код, представляющий бизнес-правила, должен быть сердцев системы, а другие задачи - просто подключаться к ним. Реализация
бизнес-правил должна быть самым независимым кодом в системе, готовым к многократному использованию.

## Кричая архитектура

Цель архитектуры - хорошие архитектуры опираются на варианты использования и помогают архитекторам описывать структуры,
поддерживающие эти варианты использования, не связывая себя фреймворками, инструментами и окружениями. Фреймворки
относятся к возможностям, которые должны оставаться открытыми. Ваша архитектура должна рассказывать о системе.

## Чистая архитектура

Системы обладающие характеристиками:
- независимость от фреймворков
- простота тестирования
- независимость от UI
- независимость от БД
- независимость от внешних агентов

Луковица:
- Фреймворки и драйверы (Веб, устройства, UI, внешние API)
    - Адаптеры интерфейсов (Контролеры, шлюзы, презентаторы)
        - Прикладные бизнес-правила (Варианты использования)
            - Бизнес-правила уровня предприятия (Сущности)

Правило зависимостей (Dependency Rule):
_зависимости в исходном коде должны быть направлены внутрь, в сторону высокоуровневых политик_

Разделив ПО на уровни и соблюдая правило зависимостей, вы создаете систему, которую легко протестировать.

## Презентаторы и скромные объекты

Идея шаблона "скромный объект" - разделить поведение на два модуля или класса. Один из модулей, который
называется "скромный", содержит всее, чтос с трудом поддается тестированию, в в иде, упрощенном до предела. Второй - 
все, что было выброшено из "скромного" модуля.

Представление (View) - это "скромный" объект, сложный для тестирования. Он просто переносит данные в GUI, никак не
обрабатывая их.

Презентатор (Presenter) - легко тестируемый объект. Его задача - получить данные от приложения и преобразовать их так,
чтобы View могло просто переместить их а экран (View Model).

Раздел между легко и тяжело тестируемыми часто совпадает совпадает с архитектурыми границами. Так же шлюзы к базам данным,
ORM, services.

Взаимодействие через архитектурную границу почти всегда осуществляется с применением некой просто структуры данных,
и граница часто делит что-то на сложное и просто для тестирования. Применение этого шаблона для организации архитектурных
границ значительно улучшает возможность тестирования системы в целом.

## Неполные границы

Полноценные архитектурные границы обходятся дорого, т.к. требует значительных усилий для создания и сопровождения.

Неполная граница - пропустить последний шаг - заложить и оставить в одном компоненте.

Одномерные границы:
- шаблон "Strategy"
- шаблон "Facade"

Одна из задач архитектора - решить, где провести архитектурную границу и как ее реализовать, частично или 
полностью.

## Уровни и границы

YAGNI vs Закладывать границы заранее:
- игнорировать границы
- неполные границы
- полные границы

Важно наблюдать за развитием системы, омтечать места, где может потребоваться провести новую границу, и затем следить
за появлением первых трений, возникающих из-за отсутствия границ.

Цель - взвесить за и против, создать границу в точке перегибра, когда реализовать ее дешевле, чем продолжать игнорировать.

## Главный компонент

Main - компонент, который создает другие компоненты, наблюдает за ними и координирует их действия.

Компонент Main - думать о нем, как о плагине, находящемся за архитектурной границей. Например, Main для разработки,
для тестирования, для прода, можно для каждой страны, или для каждого клиента. Тогда проблемы настройки решаются
немного проще.

## Службы: большие и малые

Заблуждение о независимости - чтобы добавить новое поле в запись, которая передается между службами, придется изменить
все службы, использующие это новое поле. Так же потребуется согласовать интерпретацию этого поля.

Заблуждение о возможности независимой разработки и развертывания. Любая сквозная задача потребует участия от всех.

Службы (services) не являются архитектурно значимыми элементами. Архитектура системы определяется границами, проводимыми
внутри этой системы, и зависимостями, пересекающими эти границы. Архитектура не определяется физическими механизмами, 
посредством которых элементы взаимодействуют и выполняются.

## Границы тестов

Тесты по своей природе следуют правилу зависимостей; они очень детальны и конкретны; и они всегда зависят от тестируемого
кода. Фактически тесты можно считать самым внешним кругом архитектуры.

Но тесты это часть системы, и к их проектированию следует подходить с неменьшим вниманием. Тесты, которые не 
проектируются как часть системы, получаются хрупкими и сложными в сопровождении.

Например, можно создать отдельный API для тестирования бизнес-правил.






