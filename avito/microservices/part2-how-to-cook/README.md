### TL DR;
Как выносить, когда выносить, что выносить.

Движение в сторону микросеревисов это скейлинг продуктового функционала в оси dimensions to scaling (функциональная декомпозиция, автономность масштабирования)
Нетривиально - как "отпилить"? Как не сделать сервис, который не автономен? Цель понизить связанность компонентов.

### Связность
	- жесткая
		- взаимодействие команд при разработке, каждый инкремент требует, чтобы кто-то другой тоже поработал
			- это приводит к bottleneck
		- как отпилить продуктовый функционал
			- является законченным продуктовым функционалом (должно нести ценность бизнесу)
			- не зависит от монолита
			- вынос атомарными этапами
			- как понять важен ли сервис бизнесу?
				- имеется domain entity (сущность с данными, например users, messages, emails)
				- bounded context (продуктовый слой бизнес-логи вокруг domain entity, например, валидация, которая сохраняет консистентность)
				- данные golden source для своей предметной области
			- пример (содержит продуктовую ценность):
				+ сервис подачи объявлений
				+ service messanger
				+ сервис поисковых фильтров
				- (плохой пример) service-feature-toggle
					- протекание доменных абстракций
					- в одной базе храним данные из разных сервисов
				- (плохой пример) service-api-config (сервис настроек api)
			- является предметом частных изменений
				- git effort ...
			- не причина для отпила
				- наличие класса репозитория ("увидели класс shops, давайте выносить в отдельный микросервис"), надо разбираться
				- (?) php-fpm кэш (?) стейт хранит? (ну видимо да)
				- наличие табличек в базе
				- наличие общей кодовой базы
					- библиотека, common code
			- вынос осуществляется атомарными этапами
				- когда есть старая логика и новая, есть gateway с роутингом, можем долго остаться в промежуточном состоянии. Если оно неизбежно, сокращать его время жизни
	- Runtime
		- когда нужно сделать синхронный поход в другой сервис

### Пишем сервис с нуля
	- функционал нужно делить вертикально
		- FE, BE, storage (чтобы атомарно доставить инкремент)
	- минусы горизонтальных сервисов
		- I в SOLID-e
		- отказоустойчивость
		- что делать, если нужен feature-toggle
			- каскадно транслировать в другие сервисы
			- все тогглы д.б. инкапсулированы внутри подконтрольных сервисов
	- независимые базы данных
	- монолит не ходит в новый сервис. В то время сервис может ходить в монолит. (нет автономоности, надо делать 2 деплоя - сервис + монолит)
	


### Что можно было бы распилить?
	- avi-lb -> avi-http -> api-gateway
	- avi-lb -> avi-http -> monolith (хорошо бы выпилить это, перетащить в api-gateway)

### api-gateway
	- добавить новый route, и fallback на старый
		- в роутинге не добавлять бизнес-логику

### Технические подходы
	 - graceful degradation
		- null object pattern
			- или пустоты или мок (если эти данные не участвуют в продуктовом сценарии) (как пример отдавать пустое имя юзера)
	 - health check
		- при первом запуске
			- собственные ресурсы: например, redis + postgres, но не внешний сервис
				- основные хранилища
				- кэши сервиса
				- s3
			- не проверяем
				- зависимые сервисы
				- не создаем locks для master/slave топологии инстансы сервиса
		- под нагрузкой
			- зависит от сервиса, можем продолжать предоставлять сервис для 99% пользователей, например проверять только cache
				- критически важные ресурсы
			- например 500-ки на запись, 200 на чтение
				- некритичные холодные хранилища
	- best practices при работе с внешними ресурсами
		- модель аварии: исходный сервис timeout 50ms -> следующий сервис timeout 1s
		- timeouts
		- pool на ресурс
			- обязательно иметь ограниченный pool на внешние ресурсы
			- ..
			- ..
		- retry
			- >1 никакой пользы
			- exponential timeouts
			- имеет смысл делать retry timeout + random при моргании сети
		- тесты с примерами (репозиторий ansfilatov + fault-tolerance-demo):
			- без таймаута, без пула. Под нами деградирует сервис, у нас копятся горутины - нас убивает oom killer
			- без таймаута, пул 500 коннектов
			- таймаут 1 сек, пул 500 коннектов
		- каскадно передавать таймауты с fe -> database
		- circuit breaker
			- маскируем неудачные ответы, если часто 500, убираем оттуда нагрузку
	- шина данных
		- предпосылки
			- синхронные походы не масштабируются
		- фронтенд может быть не готов работать асинхронного
		- функции
			- асинхронное взаимодействие сервиса
			- нет гарантии порядка
			- at least once
			- четко деклалированные схемы
				- brief (то же самое что контракт для API)
			- полный state VS id сущности
				- развязывание связей
				- graceful degradation "почти из коробки"
				- нет стоит передавать большие куски данных (думаем о консистентности)
	- распределенные транзакции
		- саги
			- оркестрированные (знание про все шаги в едином месте, поддержка синхронности выполнения)
				- только в одно сторону
				- сложнее инфра
				- ...
			- хореографическое
			- AC(I)D - изоляции нету
		- cqrs
			- command model
			- query model


	
